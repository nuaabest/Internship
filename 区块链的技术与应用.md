作　　者：厉成毅

日　　期：2020.02.23



##BTC

### 一、区块链用到的密码学技术

#### 1、哈希

**区块链是用的SHA-256哈希函数**

需要有以下三个性质：

**①collision resistance**

将文件进行哈希保证其不会被篡改，尽量不会出现哈希碰撞                  

**②hiding**

哈希函数是单向的，输入空间要很大，分布要均匀                   

**③puzzle friendly**

哈希值的计算结果是无法事先预测的

#### 2、签名

创建一个比特币账户之后，会产生一对公、私钥，签名时用的是私钥，验证的时候用的是公钥。**在比特币中，是先对msg进行一个哈希，然后再对哈希进行签名。**

**挖矿就是：**

每个区块会有一个block header，在这个部分内部会有一个nonce的区域，这个区域是一个随机数，会把随机数带入哈希函数参与运算，要计算的结果小于等于target，假设所有的输出空间是L，target只是前面的很少一部分，挖矿没有捷径，只能进行无数次的计算



### 二、比特币需要的数据结构

首先需要理解一下**哈希指针（hash pointers）**的含义，普通指针只是保存一下结构体在内存的位置，但是哈希指针还需要保存该结构体的哈希值

#### 1、区块链

![](C:\Users\Administrator\Desktop\workspace\Internship-script\block_link.png)

左边第一个的区块是最开始的（genesis block），最右边的是最近产生的区块（most recent block）

这里的H( )用来表示前面一个区块的哈希指针，每个区块都会保留前一个区块的哈希指针，是由前一个区块的所有内容通过哈希形成的，最近产生的区块也会有一个它的哈希指针存在，存在于系统之中，可以通过这个哈希指针判断之前的数据是否有被修改。

#### 2、Merkle tree

***区块是可以分为下面两个部分的：block header（只保留有root hash值）和block body（这个里面保留有具体的交易的各种信息）***

Merkle tree和binary tree的区别在于是用哈希指针还是普通指针（**我并不确定是否是唯一区别**）

区块链有两种节点：`全节点`和`轻节点`

​				   全节点是存有完整区块链副本的设备

​				   轻节点是只包含区块block header部分的设备

Merkle tree可以提供***Merkle proof***（即指一个交易到root hash的路径），可以判断一个交易是否存在于该Mekle tree中

![](C:\Users\Administrator\Desktop\workspace\Internship-script\Merkle_tree.png)

对于某些轻节点，不会存有全部信息，仅仅包含block header，只有一个哈希值而已，可以通过下面的方式进行判断：
　　首先该按轻节点向全节点发出一个请求，请求一个Makle proof，请求的这个Makle proof需要包含要查看的tx叶节点，全节点收到请求之后会把倒数第一行的H()（红色）发送给轻节点，轻节点通过把自己的本地哈希值和全节点发送过来的一起进行运算会得到倒数第二行的H()（绿色本地的），然后全节点会把另一个H()（红色）发过来，继续这种运算，最后得到一个最后的root hash，再与区块中s的root bash进行比较，结果不一样就证明该交易不存在。



### 三、比特币用到的协议

首先了解一下block header和block body都放有哪些内容：

**block header：**①当前使用的版本信息 ②哈希指针 ③Merkle root hash ④nBits域 ⑤nonce域

**block body：**包含交易的信息（transaction list）

区块链中的每个交易都会有两部分组成：**输入部分**（币的来源+发币方的公钥）、**输出部分**（收款方的公钥的哈希）

#### 1、Consensus in BitCoin

**longest valid chain原则**

简述一下比特币依靠区块链交易的过程：

在整个区块链的体系中，会有一些成员是用来生成区块的，这些生成区块的过程就是挖矿，挖矿即是找到一个随机数将其放进拥有交易信息的区块中，然后该区块的哈希能够形成一定的要求**（这个要求就是哈希结果前面要有多少个指定的0，这个0的数量是在变化的，为了保证每产生一个区块的时间相对稳定）**，生成一个区块后就能获得一定的区块奖励，比特币的来源只有这个区块奖励或者说是产生交易的用户给定的一些交易奖励。所谓的最长有笑脸原则就是每个节点可能会在某一个部分产生链的分歧，但是他永远只相信最后最长的那条链的信息，也就是说，除非有某个矿工拥有整个系统将近50%的算力那么他都没可能改变一个用户所要接受的正确信息。



### 四、比特币系统的实现

#### 1、UTOX数据结构

在比特币系统中的全节点都会有一个**UTOX（Unspent Transaction Output）**数据结构，即是未花出去的交易的输出的集合：
　　假设交易一：**A给了B**5个BTC，交易二：**A给C**3个BTC，如果B又把这5个BTC再交易出去则不会将A给B的输出放入UTOX，如果C没有交易出去，就放入UTOX。
　　UTOX集合的每个元素都有下面两个部分：
　　①产生这个输出的交易的hash
　　②它在这个交易中是第几个输出
　　UTOX的作用是避免产生double spending

####2、挖矿难度的调整（每隔2016个区块调整一下挖矿难度）

**block header的部分内容**

~~~c++
class CBlockHeader
{
    public:
    	int32_t nVersion;
    	uint256 hashPreBlock;
    	uint256 hashMerkleRoot;
    	uint32_t nTime;
    	uint32_t nBits;
    	uint32_t nNonce;
}
~~~

可以通过下面这个图理解一个块的内容：

![](C:\Users\Administrator\Desktop\workspace\Internship\block_example.jpg)

在这个的nNonce这个域只有32位，所以总共只有$2^{32}​$种情况，随着近年挖矿人数的上去以及挖矿设备的进步，如果挖矿难度不提升，一个区块的产生就会越来越快，如果出块时间太短挖矿节点就会快速的产生区块，然后由于同一时间发布的区块数量的上升，就会导致区块链产生分叉，而且分叉会很频繁并且分叉会变多，如果分叉过多，恶意节点就可以发动自己的全部算力去扩展一个分叉，就很快就可以扩展该链为合法最长链，因为好的节点的算力被分散。调整难度就是调整target

$target=target \times{{actual_time} \over {expected_time}}$

以上就是调整难度的公式。

当难度经过调整之后纯粹的调整nNonce域可能是找不到需要的随机数的，此时块头中还有nTime域可能可以进行调整，因为区块链中对于时间不是严格的要求，只要差的不是很多就可以。最主要调整的位置还是hashMerkleRoot这个域，每个区块都会有一个铸币交易（是比特币系统中产生币的唯一来源），在铸币交易中有一个CoinBase域，这个域是可以设置一部分任意修改然后让哈希值满足条件。